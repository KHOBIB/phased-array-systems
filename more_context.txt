Please help me write a detailed software design document and detailed requirements for a phased array antenna system design, optimization, and performance visualization for advanced wireless communications and radar applications open-source Python package to host on GitHub and pypi. 

Please use this package as a dependency: https://github.com/jman4162/Phased-Array-Antenna-Model, https://pypi.org/project/phased-array-modeling/

Context of my past phased array (model-based engineering) and MDAO work that I want to encapsulate in this Python package: 

	•	Phased Array Antenna Engineering Industry Talks
	◦	Multidisciplinary System Design Optimization Using Model-Based Engineering to Support Phased Array Antenna Architectural Trades
	▪	Presentation Slides
	◦	A Model-Based Systems Engineering (MBSE) Approach to the Design & Optimization of Phased Array Antenna Systems
	▪	Presentation Slides
	▪	Webinar link
	◦	Featured ANSYS Customer Testimonial: ModelCenter + Northrop Grumman



https://github.com/jman4162/electromagnetics-work-samples/blob/main/Phx2018UC_MDAO_Northrop-Grumman_Hodge.pdf

https://github.com/jman4162/electromagnetics-work-samples/blob/main/A%20Model-Based%20Systems%20Engineering%20(MBSE)%20Approach%20to%20the%20Design%20%26%20Optimization%20of%20Phased%20Array%20Antenna%20Systems-MC_Presentation-2020-Final-1.pdf


https://github.com/jman4162/electromagnetics-work-samples/blob/main/Hodge_John_ECE%205635%20Radar%20Systems_REVISED.pdf

----


Below is a GitHub-ready **Software Design Document (SDD)** + **detailed requirements** for an open-source Python package that encapsulates your **MBSE/MDAO phased-array system trade study** workflow (performance ↔ SWaP-C ↔ cost ↔ mission metrics), while using your existing **`phased-array-modeling`** package as the core EM/pattern engine (dependency).

I’ll refer to the new package as **`phased-array-systems`** (rename as you like).

---

# Phased Array Systems (Python) — Software Design Document

## 1) Purpose and Scope

**Goal:** Build an open-source Python package for **phased array antenna system design, optimization, and performance visualization** for advanced **wireless communications** and **radar** applications. The package will support **trade-space exploration** (DOE), **optimization**, and **traceable requirements verification** in an MBSE/MDAO-inspired workflow (requirements → architecture → analytical models → trade studies → visualization → best design selection).

This is directly aligned with:

* A **ModelCenter-style** parametric *performance vs SWaP-C* trade study: inputs like frequency, bandwidth, array grid, amplifier power per element, scan angle, number of beams, and required SNR; outputs like receiver SNR, link margin, EIRP, beamwidth, size/weight/prime power/power density/cost. 
* Using DOE to evaluate hundreds of configurations and grey-out non-compliant cases. 
* A modular, reconfigurable analytical cost-performance model tied to mission/system analysis. 

**Core dependency:** `phased-array-modeling` (PyPI) / `Phased-Array-Antenna-Model` (GitHub). The dependency already provides:

* array geometries, steering, tapering, null steering, multi-beam
* impairments (mutual coupling, quantization, failures, scan blindness)
* 2D/3D visualization (matplotlib + plotly) and UV-space plots ([PyPI][1])

PyPI currently lists `phased-array-modeling` **v1.2.0 released Jan 26, 2026**, Python >=3.8, and the package structure (`core.py`, `geometry.py`, `beamforming.py`, `impairments.py`, `visualization.py`, etc.). ([PyPI][1])

---

## 2) Design Principles (MBSE/MDAO Inspired)

This package explicitly implements an **integrated model framework**: connect **requirements**, **architecture/descriptive models**, and **analytical models**, then run trade studies and feed results back into the descriptive view. 

Key principles:

1. **Traceability:** requirements are first-class objects and can be “verified” by analytical evaluations (mirrors “capture requirements in SysML” → verify via integrated analytical models). 
2. **Model composability:** integrate disparate subsystem models (RF, thermal, power, cost, etc.) to do system-level trades. 
3. **Trade-space first:** DOE and Pareto frontiers over “best” design sets, with constraints & grey-out of infeasible designs. 
4. **Lifecycle fidelity growth:** support progression from fast analytical models to higher fidelity “installed pattern” imports from full-wave tools (FEKO/HFSS/etc.) when available. 
5. **Fast iteration:** automate wiring between models to reduce transcription error and enable quick evaluation (seconds/minutes). 

---

## 3) Users and Primary Use Cases

### 3.1 Personas

* **Phased array systems engineer**: wants requirements-driven architectural trades (performance vs SWaP-C/cost).
* **Radar engineer**: wants detection-level performance (PD/PFA/SNR thresholds), waveform and scan trades.
* **Wireless comms engineer**: wants link budgets (SNR margin, EIRP, beamwidth) and multi-beam capacity trades.
* **Researcher/educator**: wants reproducible analysis notebooks and plots.

### 3.2 Core Use Cases

1. **Comms link feasibility trades**: vary array size, Tx power per element, frequency, bandwidth, scan angle; compute receiver SNR and margin; produce Pareto plots (e.g., “power-aperture trade study”). 
2. **Radar detection trades**: compute received power/noise floor and required SNR thresholds (PD/PFA) and show margin. Your radar writeup uses PD=0.9, PFA=1e-8 examples with different Swerling cases and SNR thresholds. 
3. **Architecture comparison**: compare element choice / tile/subarray architecture vs bandwidth/scan/power handling (requirements drive RF front-end architecture). 
4. **Sensitivity + explainability (engineering)**: scatter-matrix and response surfaces across all inputs/outputs to reveal interactions. 
5. **Optimization**: constrained optimization to satisfy link margin while minimizing cost/weight/power. 

---

## 4) Non-Goals (Explicit)

* Not a full-wave EM solver (HFSS/CST/FEKO replacement). Instead, allow import of high-fidelity results when available. 
* Not a SysML authoring tool. We’ll implement a lightweight requirements/architecture representation that can *interoperate* with SysML exports (CSV/JSON).
* Not a real-time DSP radar tracker. Focus is on design-time performance modeling and trade studies.

---

## 5) System Overview and Architecture

### 5.1 High-level architecture

**Layer 0 — Core dependency (EM/pattern engine):**

* `phased-array-modeling` provides geometries, weights, array factor/pattern computation, impairments, and plots. ([PyPI][1])

**Layer 1 — System models (this package):**

* Requirements model (constraints + verification)
* Architecture model (array + RF chain + power + thermal + cost)
* Analytical performance models (comms + radar + beam scheduling approximations)
* Trade study engine (DOE + optimization + Pareto)
* Visualization & reporting (dashboards, scatter matrices, Pareto plots)

**Layer 2 — Interfaces / IO:**

* Import/export (CSV/JSON/Parquet)
* Optional adapters (FEKO/HFSS “installed patterns”, measured patterns)

### 5.2 Module breakdown (proposed)

```
phased_array_systems/
  ├── requirements/         # Requirements objects, constraints, verification results
  ├── architecture/         # Array + RF front-end + power + thermal + cost blocks
  ├── models/
  │    ├── antenna/         # Wrap phased-array-modeling calls, pattern metrics extraction
  │    ├── comms/           # Link budget models, SNR/margin, throughput proxies
  │    ├── radar/           # Radar equation, PD/PFA->SNR threshold helpers, scan/time
  │    ├── environment/     # Atmospheric/rain loss hooks, threat/environment models
  │    └── mission/         # Simple mission scoring / coverage / scan volume metrics
  ├── trades/
  │    ├── doe.py           # DOE generation + batch evaluation
  │    ├── pareto.py        # Pareto extraction + constraint filtering
  │    ├── optimize.py      # Constrained optimization wrappers
  │    └── sensitivity.py   # Scatter matrices, correlation, Sobol (optional)
  ├── viz/
  │    ├── plots.py         # Pareto, scatter-matrix, KPP dashboards, heatmaps
  │    └── reports.py       # HTML/Markdown report generation
  ├── io/
  │    ├── schema.py        # Pydantic schemas for configs and results
  │    ├── exporters.py     # CSV/JSON/Parquet
  │    └── importers.py     # SysML export ingest, installed pattern ingest
  └── cli.py                # CLI entry points
```

---

## 6) Data Model

### 6.1 Canonical objects

**`Requirement`**

* id, name, rationale, units
* type: constraint, objective, threshold, target
* expression: callable or declarative (e.g., `snr_margin_db >= 3`)
* verification method: which analysis produces it
* status: pass/fail/unknown + margin

**`Architecture`**

* `ArrayConfig` (geometry, element spacing, subarraying, scan range)
* `RFChainConfig` (Tx power per element, NF, losses, beam count)
* `PowerThermalConfig` (prime power, efficiency, heat)
* `CostConfig` (HPA cost, tile cost, scaling laws)

These align to your “inputs” and “outputs” framing for performance vs SWaP-C analysis. 

**`AnalysisCase`**

* architecture + scenario + requirement set + analysis options
* scenario examples: comms link, radar detection, scan schedule

**`KPPResult`**

* computed KPIs/KPPs: SNR_rx, link margin, EIRP, beamwidth, weight, cost, prime power, etc. 
* plus metadata: timestamps, versions, random seeds, solver settings

**`TradeStudyResult`**

* dataframe-like table of evaluated cases
* feasibility flags (grey-out infeasible points concept) 
* Pareto sets and recommended “best design” under priorities

### 6.2 Storage formats

* Small: JSON + CSV
* Medium/large: Parquet (preferred) + optional compression
* Always store: dependency version hashes + config snapshot for reproducibility

---

## 7) Detailed Functional Requirements

### 7.1 Requirements capture & verification

**FR-REQ-1**: Provide a Python API to define requirements (thresholds/constraints/objectives) with units and rationale.

**FR-REQ-2**: Support requirement traceability: each requirement links to a computed metric and stores pass/fail + margin (mirrors “requirements linked for traceability; verified using integrated analytical models”). 

**FR-REQ-3**: Allow importing requirements from CSV/JSON (compatible with SysML export conventions), mapping requirement IDs to expressions.

### 7.2 Architecture modeling

**FR-ARCH-1**: Represent phased array architectural parameters: geometry type, element count, spacing, scan range, subarray strategy.

**FR-ARCH-2**: Represent RF front-end architecture choices driven by requirements such as bandwidth/scan/power handling (element archetype tags + constraints). 

**FR-ARCH-3**: Include SWaP-C & cost parameters as first-class inputs (size, weight, prime power, power density, cost). 

### 7.3 Antenna/pattern modeling (via dependency)

**FR-ANT-1**: Use `phased-array-modeling` to create geometries, compute patterns, and generate beamforming weights. ([PyPI][1])

**FR-ANT-2**: Expose impairments toggles (coupling, quantization, element failures, scan blindness) through the system-level API. ([PyPI][1])

**FR-ANT-3**: Extract pattern-derived metrics:

* peak gain / directivity proxy
* az/el beamwidth
* sidelobe levels
* scan loss vs angle
* integrated sidelobe metrics (optional)

### 7.4 Communications performance models

**FR-COMMS-1**: Provide a link budget model producing receiver SNR and link margin. The MBSE trade study example explicitly uses “required SNR” as an input and “SNR at receiver” and “link margin” as outputs. 

**FR-COMMS-2**: Support multi-beam allocations (number of Tx beams) and compute proxy penalties for splitting power/aperture (configurable model). 

**FR-COMMS-3**: Output EIRP and beamwidth as KPPs. 

### 7.5 Radar performance models

**FR-RAD-1**: Implement monostatic radar equation utilities for received power and SNR margin.

**FR-RAD-2**: Implement detection threshold helpers for PD/PFA → required SNR (support Swerling-type approximations and/or user-provided thresholds). Your radar writeup demonstrates using PD=0.9 and PFA=1e-8 with different required SNR values depending on target fluctuation model. 

**FR-RAD-3**: Support integration gain models (coherent/noncoherent) and dwell time / PRF constraints as optional radar search trade knobs (consistent with your discussion of pulses, dwell time, and integration gain). 

### 7.6 Trade study engine (DOE + Pareto + optimization)

**FR-TRADE-1**: Provide DOE generation (Latin hypercube, grid, random, user-defined) and batch evaluation across hundreds of designs (e.g., “DOE tool simulates 630 system configurations”). 

**FR-TRADE-2**: Mark designs infeasible if any requirement fails; plots must “grey-out” infeasible points. 

**FR-TRADE-3**: Compute Pareto optimal frontiers for 2–3 objectives (e.g., max EIRP vs cost; include prime power as third axis). 

**FR-TRADE-4**: Provide constrained optimization: satisfy link margin / detection requirements while minimizing cost/weight/power (mirrors “built-in optimization tools help discover best design”). 

### 7.7 Visualization & reporting

**FR-VIZ-1**: Scatter-matrix across all inputs and outputs to reveal interactions (explicitly called out in your MBSE slides). 

**FR-VIZ-2**: Pareto plots, constraint shading, best-design highlighting (blue→red ranking shading concept). 

**FR-VIZ-3**: Generate a single “Design Report” (Markdown/HTML):

* requirements table (pass/fail/margin)
* architecture summary (SWaP-C)
* key plots (Pareto, scatter, pattern cut summaries)
* reproducibility block (versions, seeds)

### 7.8 Import/export and high-fidelity hooks

**FR-IO-1**: Export evaluated cases and results (CSV/JSON/Parquet).

**FR-IO-2**: Import “installed” patterns from external EM tools and use them to override/augment analytical patterns (ties to “installed array performance using FEKO EM solver”). 

---

## 8) Non-Functional Requirements

**NFR-1 Reproducibility:** Any trade study can be rerun with identical results given the same config + seed.

**NFR-2 Performance:** Batch evaluation must scale to 1e3–1e5 cases for lightweight analytical models; pattern calls should be vectorized and optionally cached (dependency already targets high-performance vectorization). ([PyPI][1])

**NFR-3 Extensibility:** New subsystem models (thermal, cost, environment) must be pluggable via a simple interface (`evaluate(architecture, scenario) -> metrics`).

**NFR-4 Packaging:** Python >=3.8 compatibility to match dependency requirement. ([PyPI][1])

**NFR-5 Testability:** Unit tests for each model; regression tests for trade outputs; golden-data snapshots for a few canonical architectures.

**NFR-6 Documentation:** Tutorials must include at least:

* Comms link margin trade study
* Radar detection trade study (PD/PFA threshold)
* DOE + Pareto selection
* Sensitivity scatter-matrix

---

## 9) Key Interfaces (API Sketch)

### 9.1 Python API (proposed)

```python
from phased_array_systems import (
    RequirementSet, Architecture, Scenario,
    CommsLinkModel, RadarDetectionModel,
    TradeStudy, ParetoObjectives
)

reqs = RequirementSet([
    ("REQ-SNR-MARGIN", "Link margin >= 3 dB", lambda m: m["link_margin_db"] >= 3),
    ("REQ-WEIGHT", "Weight <= 35 kg", lambda m: m["weight_kg"] <= 35),
])

arch = Architecture.from_dict({
    "array": {"type": "rectangular", "nx": 16, "ny": 16, "dx_lambda": 0.5, "dy_lambda": 0.5},
    "rf": {"tx_power_w_per_elem": 5.0, "noise_figure_db": 3.0, "n_tx_beams": 1},
    "cost": {"hpa_cost_usd": 120.0, "tile_cost_usd": 500.0},
})

scenario = Scenario.comms_link(range_km=200, bandwidth_hz=100e6, freq_ghz=10, required_snr_db=14)

model = CommsLinkModel()  # uses phased-array-modeling under the hood
metrics = model.evaluate(arch, scenario)
verification = reqs.verify(metrics)
```

### 9.2 CLI (proposed)

* `pasys run config.yaml` → evaluates one architecture + scenario + requirements, outputs report
* `pasys doe config.yaml` → DOE batch study → `results.parquet` + plots
* `pasys pareto results.parquet --x cost_usd --y eirp_dbw` → Pareto extraction + highlights

---

## 10) Implementation Details: How We Use `phased-array-modeling`

### 10.1 Adapter layer

Implement a thin wrapper module, e.g. `models/antenna/pa_adapter.py`, that:

* creates geometry via `phased_array.create_*_array(...)`
* generates weights (steering, tapering, multi-beam, null steering)
* computes patterns/cuts (`compute_full_pattern`, `compute_pattern_cuts`)
* computes metrics (beamwidth, peak gain proxy, sidelobes, scan loss)

Dependency quick start and module structure are stable reference points. ([PyPI][1])

### 10.2 Pattern metrics extraction

Provide consistent outputs to system models:

* `g_peak_db`
* `beamwidth_az_deg`, `beamwidth_el_deg`
* `eirp_dbw` (combine gain proxy with Tx power/losses)
* `scan_loss_db` at angle

---

## 11) Validation & Verification Strategy

This package is about **virtual integration for earlier V&V** (explicitly called out in your MBE deck). 

### 11.1 Verification (software)

* Unit tests for each metric function and each model block
* Property tests (monotonic trends): e.g., increasing elements should generally increase gain / narrow beam (within scan constraints)
* Snapshot tests for Pareto extraction and requirement filtering

### 11.2 Validation (engineering)

* Compare analytical pattern results to a few known benchmarks (textbook arrays)
* Optional: import FEKO/HFSS installed patterns and compare “installed vs ideal” deltas 
* Radar: validate radar equation outputs and SNR margins against your report cases (PD/PFA thresholds and example SNR values). 

---

## 12) Roadmap (Practical Milestones)

### Milestone 1 — “Comms trade study MVP”

* Requirements objects + verification table
* Architecture config schema
* Comms link model producing SNR/link margin/EIRP/beamwidth/SWaP-C outputs 
* DOE + Pareto + scatter-matrix (matplotlib)
* Export results (Parquet + CSV)

### Milestone 2 — “Radar detection MVP”

* Radar equation utilities + PD/PFA threshold support (with user-provided or built-in approximations) 
* Dwell/integration knobs (optional but consistent with your integrated pulse discussion) 

### Milestone 3 — “High-fidelity hooks + reporting”

* Installed pattern import interface 
* HTML/Markdown report generation
* CLI commands stabilized

---

## 13) GitHub Repository Structure and Tooling

* `src/phased_array_systems/...` (src-layout)
* `tests/` (pytest)
* `examples/` (notebooks + scripts)
* `docs/` (mkdocs-material or sphinx)
* CI: GitHub Actions (lint, tests, build, publish)
* Packaging: `pyproject.toml` with extras:

  * `plotting` (plotly, kaleido optional)
  * `dev` (pytest, ruff, mypy)
* Pin `phased-array-modeling>=1.2.0` (or your preferred minimum) since that version is current on PyPI as of Jan 26, 2026. ([PyPI][1])

---

# Appendix A — Canonical Metrics (KPP/KPI List)

These map cleanly onto the variables in your MBSE trade study framing. 

**Performance**

* `snr_rx_db`, `link_margin_db`
* `eirp_dbw`
* `beamwidth_az_deg`, `beamwidth_el_deg`
* `scan_loss_db(angle)`
* `sll_db` (sidelobe level)
* `capacity_proxy` (optional comms throughput proxy)

**SWaP-C**

* `size_m3`, `weight_kg`
* `prime_power_w`, `power_density_w_per_kg`
* `cost_usd`

**Radar-specific**

* `snr_det_db`, `pd`, `pfa`, `range_km`, `rcs_m2`
* `integration_gain_db`, `dwell_time_s`, `scan_time_s`

---

# Appendix B — Design Trade Study Templates

## B.1 “Power–Aperture” comms study

Inputs: N elements, P_elem, f, BW, scan angle, required SNR
Outputs: SNR_rx, link margin, EIRP, beamwidth, prime power, weight, cost
Pareto: maximize EIRP / margin vs minimize cost/prime power
(Directly mirrors your illustrated power–aperture Pareto framing.) 

## B.2 “EIRP vs Cost vs Prime Power” study

Three-axis manifold plot is explicitly called out in your MDAO slides. 

---

If you want, I can also generate a **starter `README.md`**, **`pyproject.toml`**, and a **minimal skeleton package layout** that implements Milestone 1 (comms trade study MVP) on top of `phased-array-modeling`—but the document above should be enough to hand to an agent and begin building immediately.

[1]: https://pypi.org/project/phased-array-modeling/ "phased-array-modeling · PyPI"


Got it — here’s the continuation, expanding the SDD into **implementation-ready detail**: component contracts, schemas, model equations/interfaces, trade/optimization pipeline, caching/perf, and repo/devops requirements.

---

## 14) Detailed Component Specifications

### 14.1 Requirements subsystem (`requirements/`)

**Key classes**

* `Requirement`

  * `id: str`
  * `name: str`
  * `description: str`
  * `units: Optional[str]`
  * `kind: Literal["constraint","threshold","objective","target"]`
  * `metric_key: str` (e.g., `"link_margin_db"`)
  * `op: Literal[">=","<=","==",">","<"]`
  * `value: float`
  * `severity: Literal["must","should","nice"]`
  * `tags: list[str]` (e.g., `["comms","KPP"]`)
* `RequirementSet`

  * `requirements: list[Requirement]`
  * `verify(metrics: dict) -> VerificationReport`
* `VerificationReport`

  * `passes: bool`
  * `per_requirement: list[RequirementResult]`
  * `failed_ids: list[str]`
* `RequirementResult`

  * `requirement_id`
  * `metric_value`
  * `pass_fail`
  * `margin` (signed margin in requirement’s direction)
  * `notes`

**Functional requirements**

* **FR-REQ-4**: A requirement can be expressed declaratively (`metric_key`, `op`, `value`) OR as a custom function (`callable`) for complex logic (e.g., piecewise constraints).
* **FR-REQ-5**: Requirement evaluation must be **unit-aware** when possible (use `pint` optional dependency; fall back to raw numbers).

---

### 14.2 Architecture subsystem (`architecture/`)

**Design choice:** treat architecture as a set of “Blocks” (MBSE-ish), but implemented as lightweight Python objects with schemas.

**Key classes**

* `ArrayConfig`

  * geometry: rectangular/circular/cylindrical/spherical/sparse
  * `nx, ny` or `n_elements`
  * spacing (in λ or meters)
  * scan limits
  * polarization / element pattern reference (optional)
  * subarraying/tile layout (optional)
* `RFChainConfig`

  * Tx: `tx_power_w_per_elem`, `pa_efficiency`, `n_tx_beams`
  * Rx: `noise_figure_db`, `rx_losses_db`
  * common losses: `feed_loss_db`, `radome_loss_db`, `misc_losses_db`
  * quantization: `phase_bits`, `amp_bits` (optional)
* `PowerThermalConfig`

  * `dc_bus_v`, `psu_efficiency`
  * `thermal_resistance_k_per_w` (optional early model)
  * `max_junction_temp_c` (optional)
* `CostConfig`

  * cost scalings: `cost_per_elem`, `cost_per_tile`, NRE placeholders
  * parametric cost models (callable hooks)
* `Architecture`

  * `.array`, `.rf`, `.power_thermal`, `.cost`
  * `.to_dict()/.from_dict()`

**Functional requirements**

* **FR-ARCH-4**: Support “architecture variants” via inheritance/overrides (e.g., baseline + delta to explore).
* **FR-ARCH-5**: Support “fidelity levels” (e.g., Level 0 analytical; Level 1 installed-pattern override).

---

### 14.3 Antenna/pattern adapter (`models/antenna/`)

This is the bridge to `phased-array-modeling`.

**Key class**

* `PhasedArrayModelAdapter`

  * `build_array(array_config) -> ArrayObject`
  * `compute_weights(array_config, beam_config) -> Weights`
  * `compute_pattern(array_obj, weights, angles) -> PatternData`
  * `extract_metrics(pattern_data) -> dict`

**Pattern-derived metrics (contract)**

* `g_peak_db` (or `directivity_peak_db`)
* `beamwidth_az_deg`, `beamwidth_el_deg`
* `sll_db` (peak sidelobe)
* `scan_loss_db` (relative to boresight peak)
* `eirp_dbw` (computed by system model from gain + power + losses)

**Functional requirements**

* **FR-ANT-4**: Provide deterministic metric extraction methods (document definitions: e.g., 3 dB beamwidth method, sidelobe window rules).
* **FR-ANT-5**: Provide caching keyed on `(array_config, beam_config, impairment_config, angle_grid_hash)`.

---

### 14.4 Communications models (`models/comms/`)

**Core output contract**

* Always return a `metrics: dict[str, float]` with at least:

  * `snr_rx_db`, `link_margin_db`, `eirp_dbw`
  * optionally `throughput_proxy_mbps`, `spectral_eff_bpshz`

**Comms scenario**

* `CommsLinkScenario`

  * `freq_hz`, `bandwidth_hz`
  * `range_m`
  * `required_snr_db` OR `modcod` (maps to required SNR via a lookup table)
  * channel loss model: `path_loss_model` (FSPL default), atmosphere/rain optional
  * pointing/scan: `scan_angle_deg`

**Baseline equations (documented, not “hardcoded forever”)**

* `EIRP(dBW) = P_tx_total(dBW) + G_tx(dBi) - L_tx(dB)`
* `P_rx(dBW) = EIRP - L_path - L_misc + G_rx(dBi)` (if separate gains; or fold into system)
* `N(dBW) = 10log10(kTB) + NF + implementation_losses`
* `SNR(dB) = P_rx - N`
* `margin = SNR - required_snr`

**Functional requirements**

* **FR-COMMS-4**: Support power split across multi-beams: `P_per_beam = P_total / n_tx_beams` (plus optional digital beamforming loss factor).
* **FR-COMMS-5**: Provide pluggable propagation loss models (FSPL, ITU-R hooks).

---

### 14.5 Radar models (`models/radar/`)

**Radar scenario**

* `RadarDetectionScenario`

  * `freq_hz`
  * `range_m`
  * `rcs_m2`
  * `bandwidth_hz` or receiver noise BW
  * `pd`, `pfa`
  * `swerling_case` (optional)
  * `n_pulses`, `integration_type` (coherent/noncoherent)
  * scan/dwell: `dwell_time_s`, `prf_hz` (optional)

**Outputs**

* `snr_single_pulse_db`
* `snr_required_db`
* `snr_margin_db`
* optional: `range_max_m` given margin constraint

**Functional requirements**

* **FR-RAD-4**: Allow user-provided `snr_required_db` (to avoid debates on exact threshold modeling) while still offering helper methods.
* **FR-RAD-5**: Provide integration gain approximations with documented assumptions.

---

## 15) Trade Study and Optimization Engine Design (`trades/`)

### 15.1 DOE (`doe.py`)

**Inputs**

* `DesignSpace` specification:

  * continuous vars with bounds
  * discrete vars with sets
  * categorical vars (geometry type, PA technology tag, etc.)

**Outputs**

* `CaseTable` (pandas DataFrame or polars DataFrame) with:

  * columns for all decision variables
  * unique `case_id` (stable hash)

**Sampling methods**

* Grid
* Random
* Latin Hypercube (optional dependency: `scipy.stats.qmc`)
* Sobol sequence (optional)

**Functional requirements**

* **FR-TRADE-5**: Deterministic DOE with seed control.
* **FR-TRADE-6**: Case IDs must be stable across runs for the same inputs.

---

### 15.2 Batch evaluation (`doe.py` / `runner.py`)

**Pipeline**

1. Build `Architecture` from case row
2. Compute antenna metrics (adapter)
3. Evaluate comms/radar model(s)
4. Merge into a single metrics dict
5. Verify requirements
6. Store results row:

   * metrics
   * pass/fail boolean
   * failed requirement IDs
   * runtime metadata

**Parallelism**

* Default: multiprocessing for CPU-heavy pattern sweeps
* Optional: joblib / ray (future)

**Functional requirements**

* **FR-TRADE-7**: Must support resuming from partial results (case-level caching).
* **FR-TRADE-8**: Must record exceptions per case (don’t crash whole run).

---

### 15.3 Pareto (`pareto.py`)

**Features**

* Constraint filtering first (feasible set)
* Pareto extraction for 2–N objectives
* Tie-breaking / ranking strategy:

  * weighted sum ranking
  * lexicographic ranking
  * “best compromise” (knee point heuristic)

**Functional requirements**

* **FR-TRADE-9**: Support “minimize” and “maximize” objectives per metric.
* **FR-TRADE-10**: Provide knee point extraction and label “recommended” designs.

---

### 15.4 Optimization (`optimize.py`)

**Goal:** Find architecture that satisfies constraints and optimizes objective(s).

**Recommended approach**

* Start with `scipy.optimize` (SLSQP / COBYLA) for continuous-only
* Add `pymoo` or `nevergrad` for mixed discrete + continuous multi-objective (optional extra)

**Functional requirements**

* **FR-TRADE-11**: Provide a unified `optimize()` interface that can call different solvers.
* **FR-TRADE-12**: Support “soft constraints” with penalties as fallback.

---

## 16) Visualization and Reporting (`viz/`)

### 16.1 Plots (`plots.py`)

* **Pareto plot** (2D): feasible vs infeasible coloring; highlight Pareto front; annotate top N
* **3D scatter** (cost vs EIRP vs prime power) with interactive plotly optional
* **Scatter-matrix** for sensitivity (inputs + outputs)
* **Constraint margin plot**: histogram of margins per requirement
* **Pattern summary**: embed key cuts and beam metrics

**Functional requirements**

* **FR-VIZ-4**: Every plotting function must accept either a DataFrame or a results file path.
* **FR-VIZ-5**: Plots must be reproducible from stored results without recomputing patterns.

### 16.2 Reports (`reports.py`)

Generate a single HTML/Markdown report that includes:

* architecture + scenario summary
* requirements table (pass/fail/margins)
* top plots
* “selected design” detail pages for top N

**Functional requirements**

* **FR-VIZ-6**: Report generator must be usable from CLI and Python API.
* **FR-VIZ-7**: Include a reproducibility footer (package versions, git commit hash if available).

---

## 17) Configuration Schema (YAML/JSON)

A config-driven workflow makes this feel like ModelCenter/MDAO runs.

### 17.1 Example `config.yaml`

```yaml
study:
  name: "power_aperture_trade"
  seed: 123
  output_dir: "runs/power_aperture_trade"

dependency:
  phased_array_modeling_min_version: "1.2.0"

scenario:
  type: "comms_link"
  freq_hz: 10.0e9
  bandwidth_hz: 100.0e6
  range_m: 200000
  required_snr_db: 14
  scan_angle_deg: 45
  path_loss_model: "fspl"

requirements:
  - id: "REQ-LINK-MARGIN"
    name: "Link margin"
    metric_key: "link_margin_db"
    op: ">="
    value: 3
    severity: "must"
  - id: "REQ-POWER"
    name: "Prime power"
    metric_key: "prime_power_w"
    op: "<="
    value: 1200
    severity: "should"

design_space:
  variables:
    nx: {type: "int", low: 8, high: 64}
    ny: {type: "int", low: 8, high: 64}
    dx_lambda: {type: "float", low: 0.45, high: 0.6}
    tx_power_w_per_elem: {type: "float", low: 0.5, high: 10.0}
    n_tx_beams: {type: "int", values: [1, 2, 4]}

evaluation:
  angle_grid:
    az_deg: {start: -90, stop: 90, step: 0.5}
    el_deg: {start: -90, stop: 90, step: 0.5}
  impairments:
    phase_bits: 6
    element_failure_rate: 0.0

objectives:
  - metric_key: "eirp_dbw"
    direction: "maximize"
  - metric_key: "cost_usd"
    direction: "minimize"

doe:
  method: "lhs"
  n_samples: 2000
```

**Functional requirements**

* **FR-IO-3**: Validate config via Pydantic; provide helpful error messages with field paths.
* **FR-IO-4**: Support overrides from CLI flags (e.g., `--n-samples 5000`).

---

## 18) Caching, Performance, and Scaling

### 18.1 Cache layers

1. **Pattern cache**: keyed by array + weights + impairment + angle grid hash
2. **Case cache**: keyed by full `Architecture + Scenario + Requirements version`

**Functional requirements**

* **NFR-PERF-1**: Cache must be opt-in/opt-out and support a max size / eviction policy (simple LRU is fine).
* **NFR-PERF-2**: Persist cache to disk for large DOE studies (e.g., `joblib.Memory`).

### 18.2 Fast modes vs fidelity modes

* **Fast mode:** coarse angular grid, analytical element pattern, no coupling
* **Fidelity mode:** finer grid, coupling/quantization/failures, installed patterns if provided

**Functional requirements**

* **FR-ANT-6**: Expose fidelity presets (`fast`, `balanced`, `fidelity`) with documented defaults.

---

## 19) Plugin Architecture (Extensibility)

Define a minimal interface:

```python
class ModelBlock(Protocol):
    name: str
    def evaluate(self, arch: Architecture, scenario: Scenario, context: dict) -> dict: ...
```

Then allow users to register:

* custom cost models
* thermal models
* propagation models
* mission scoring

**Functional requirements**

* **NFR-EXT-1**: Plugins discoverable via entrypoints (`pyproject.toml`) optionally.
* **NFR-EXT-2**: All blocks must be orderable, and declare their required inputs (metric dependencies).

---

## 20) Repository Deliverables and Acceptance Criteria

### 20.1 “Definition of Done” for v0.1

* Installable from PyPI (`pip install phased-array-systems`)
* One end-to-end example: comms DOE → Pareto → report
* Basic radar example: single-case detection margin report
* CI passing: lint + unit tests
* Docs site with quickstart and tutorials

### 20.2 Minimum example notebooks/scripts

* `examples/01_comms_trade_study.py`
* `examples/02_radar_detection_trade.py`
* `examples/03_multiobjective_pareto.py`
* `examples/04_impairments_sensitivity.py`

---

## 21) Concrete Work Breakdown (Build Plan You Can Hand to an Agent)

### Phase 1 (Core scaffolding)

* Pydantic schemas + config loader
* RequirementSet + verification
* Architecture objects
* Adapter wrapper around `phased-array-modeling`
* One comms model producing `snr_rx_db`, `link_margin_db`, `eirp_dbw`

### Phase 2 (Trade + viz)

* DOE generation + batch runner + resume
* Pareto extraction
* Pareto plot + scatter matrix
* Export Parquet/CSV

### Phase 3 (Radar)

* Radar scenario + radar equation + required-SNR helper hooks
* Detection margin plots

### Phase 4 (Reports + CLI)

* `pasys run`, `pasys doe`, `pasys pareto`
* HTML report generation

---

## 22) Optional: Starter Code Skeleton (Minimal)

If it helps, here’s a tiny “spine” you can paste into the repo to start wiring. (Not full implementation; it’s just the shape.)

```python
# src/phased_array_systems/requirements/core.py
from dataclasses import dataclass
from typing import Literal, Optional

Op = Literal[">=", "<=", "==", ">", "<"]

@dataclass(frozen=True)
class Requirement:
    id: str
    name: str
    metric_key: str
    op: Op
    value: float
    units: Optional[str] = None
    severity: str = "must"

def check(op: Op, x: float, y: float) -> bool:
    if op == ">=": return x >= y
    if op == "<=": return x <= y
    if op == "==": return x == y
    if op == ">":  return x > y
    if op == "<":  return x < y
    raise ValueError(op)
```

---

If you want me to keep going, the next most useful “continuation” is to write:

1. the **full Pydantic schemas** for config + results, and
2. a **detailed metric dictionary contract** (exact keys/units) for comms + radar + antenna metrics, so everything stays consistent across models, plots, and reports.
